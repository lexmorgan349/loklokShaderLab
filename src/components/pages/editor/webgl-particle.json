[{"path":"@/index.html","src":"<!DOCTYPE html>\n<html>\n  <head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <title>component</title>\n  <meta name=\"author\" content=\"\">\n  <meta name=\"description\" content=\"WebGL Art\">\n  <meta name=\"keywords\" content=\"WebGL, Art\">\n\n  <!--\n  -->\n\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.2/vue.min.js\"></script>\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/vue-router/3.0.1/vue-router.min.js\"></script>\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\"></script>\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js\" integrity=\"sha256-6fhm481uY9c152qGWIVgE7KbzaCj5WjCi3BGIpZef2E=\" crossorigin=\"anonymous\"></script>\n  <script src=\"https://threejs.org/examples/js/GPUComputationRenderer.js\"></script>\n\n  <style type=\"text/css\">\n    \n  </style>\n  </head>\n  <body>\n    <div id=\"app-attach-point\"></div>\n    <!--DO_NOT_REMOVE_ME____AUTO_INIT-->\n  </body>\n</html>"},{"path":"@/main.js","src":"//\nimport '@/style.css'\nimport app from '@/src/app.js'\n\n"},{"path":"@/style.css","src":"* {\nborder: red solid 1px;\n}\n\nhtml, body {\n  width: 100%;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n}\nhtml, body, #app {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}"},{"path":"@/src/app.js","src":"\nimport { makeAPI } from '@/src/webgl/particle.js';\n\nvar api = makeAPI();\napi.setup({ target: document.getElementById('app-attach-point') });\n\nvar clean = () => {\n  api.clean()\n};\n\n//\n"},{"path":"@/src/ui/events.js","src":"\n//\nexport default ({ target, stack }) => {\n  var mod = {};\n\n  mod.sendEvent = (args) => {\n      for (var key in stack) {\n          stack[key](args)\n      }\n  }\n\n  var ev = mod.evlt = {\n    resizer: () => {\n      if (!target) { return }\n      mod.rect = target.getBoundingClientRect()\n      mod.aspect = mod.rect.width / mod.rect.height\n      mod.sendEvent({ type: 'resize', aspect: mod.aspect, rect: mod.rect })\n    },\n    tsData: false,\n    tmData: false,\n    emitClick: false,\n    onTS: (evt) => {\n      evt.preventDefault()\n      ev.tsData = { type: 'click', isIn: true, touches: evt.touches, pageX: evt.touches[0].pageX, pageY: evt.touches[0].pageY, rect: mod.rect }\n      ev.emitClick = true\n      setTimeout(() => {\n        ev.emitClick = false\n      }, 300)\n      mod.sendEvent({ type: 'ts', isIn: true, touches: evt.touches, pageX: evt.touches[0].pageX, pageY: evt.touches[0].pageY, rect: mod.rect })\n    },\n    onTM: (evt) => {\n      evt.preventDefault()\n      mod.sendEvent({ type: 'tm', touches: evt.touches, pageX: evt.touches[0].pageX, pageY: evt.touches[0].pageY, rect: mod.rect })\n    },\n    onTE: (evt) => {\n      if (ev.emitClick) {\n        ev.emitClick = false\n        mod.sendEvent(ev.tsData)\n      }\n      mod.sendEvent({ type: 'te', isIn: false })\n    },\n    onMDN: (evt) => {\n      mod.sendEvent({ type: 'mdn', pageX: evt.clientX, pageY: evt.clientY, rect: mod.rect })\n    },\n    onMUP: (evt) => {\n      mod.sendEvent({ type: 'mup', pageX: evt.clientX, pageY: evt.clientY, rect: mod.rect })\n    },\n    onMV: (evt) => {\n      evt.preventDefault()\n      mod.sendEvent({ type: 'mv', pageX: evt.pageX, pageY: evt.pageY, rect: mod.rect })\n    },\n    onMO: (evt) => {\n      mod.sendEvent({ isIn: true })\n    },\n    onME: (evt) => {\n      mod.sendEvent({ isIn: true })\n    },\n    onML: (evt) => {\n      mod.sendEvent({ isIn: false })\n    },\n    onCL: (evt) => {\n      mod.sendEvent({ type: 'click', pageX: evt.pageX, pageY: evt.pageY, rect: mod.rect })\n    },\n    onWHL: (evt) => {\n      mod.sendEvent({ type: 'wheel', deltaX: evt.deltaX, deltaY: evt.deltaY })\n    }\n  }\n\n  setTimeout(() => {\n    ev.resizer()\n  }, 10)\n\n  var container = target\n  container.addEventListener('mouseover', ev.onMO, false)\n  container.addEventListener('mouseenter', ev.onME, false)\n  container.addEventListener('mouseleave', ev.onML, false)\n\n  container.addEventListener('mousemove', ev.onMV, false)\n  container.addEventListener('mousedown', ev.onMDN, false)\n  container.addEventListener('mouseup', ev.onMUP, false)\n\n  container.addEventListener('click', ev.onCL, false)\n  container.addEventListener('wheel', ev.onWHL, false)\n\n  container.addEventListener('touchstart', ev.onTS, false)\n  container.addEventListener('touchmove', ev.onTM, false)\n  container.addEventListener('touchend', ev.onTE, false)\n  container.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)'\n  window.addEventListener('resize', ev.resizer, false)\n  mod.uninstaller = () => {\n    container.removeEventListener('mouseover', ev.onMO)\n    container.removeEventListener('mouseenter', ev.onME)\n    container.removeEventListener('mouseleave', ev.onML)\n\n    container.removeEventListener('mousemove', ev.onMV)\n    container.removeEventListener('mousedown', ev.onMDN)\n    container.removeEventListener('mouseup', ev.onMUP)\n\n    container.removeEventListener('click', ev.onCL)\n    container.removeEventListener('wheel', ev.onWHL)\n\n    container.removeEventListener('touchstart', ev.onTS)\n    container.removeEventListener('touchmove', ev.onTM)\n    container.removeEventListener('touchend', ev.onTE)\n    window.removeEventListener('resize', ev.resizer)\n  }\n\n  return mod;\n}\n//\n"},{"path":"@/src/ui/window.js","src":"\n//\n\nexport default function setupWindow ({ stack }) {\n  var mod = {}\n\n  mod.sendEvent = (args) => {\n      for (var key in stack) {\n          stack[key](args)\n      }\n  }\n\n  window.addEventListener('message', ({ data }) => {\n    // console.log(data);\n    if (data.type === 'cw.slider') {\n      mod.sendEvent({ type: 'cw.slider', data })\n    }\n  }, false)\n\n  return mod;\n}\n\n//\n      "},{"path":"@/src/webgl/particle.js","src":"\n//\nvar THREE = window.THREE;\n\nimport setupEvents from '@/src/ui/events.js';\nimport setupWindow from '@/src/ui/window.js';\n\nexport function makeAPI() {\n    var api = {}\n\n    var WIDTH = 128\n\n    api.windowStack = {};\n    api.eventStack = {};\n    api.setup = ({\n        target\n    }) => {\n        var renderer = new THREE.WebGLRenderer({\n            alpha: true\n        })\n        api.compute = setupCompute({\n            renderer\n        })\n        api.render = setupRender({\n            renderer,\n            target\n        })\n        api.events = setupEvents({\n            target,\n            stack: api.eventStack\n        })\n        api.Window = setupWindow({\n            stack: api.windowStack\n        })\n        api.loop = setupLoop()\n    }\n\n    api.clean = () => {\n        api.loop.stop()\n    }\n\n    var setupLoop = () => {\n        var rAF = () => {\n            api.rAFID = window.requestAnimationFrame(rAF)\n\n            var result = api.compute.run()\n            api.render.run({\n                compute: result\n            })\n        }\n        api.rAFID = window.requestAnimationFrame(rAF)\n        return {\n            stop() {\n                window.cancelAnimationFrame(api.rAFID)\n            }\n        }\n    }\n\n    var makeAnimatable = ({\n        scene\n    }) => {\n\n        var particleV = require('@/src/webgl/particle/particle.vert');\n        var particleF = require('@/src/webgl/particle/particle.frag');\n\n        var geometry = new THREE.PlaneBufferGeometry(30, 30, WIDTH - 1, WIDTH - 1);\n        var material = new THREE.ShaderMaterial({\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            transparent: true,\n            vertexShader: particleV.default,\n            fragmentShader: particleF.default,\n            uniforms: {\n                opacity: {\n                    value: 1.0,\n                },\n                resolution: {\n                    value: new THREE.Vector2(window.innerWidth, window.innerHeight),\n                },\n                picture: {\n                    value: new THREE.TextureLoader().load('https://picsum.photos/200/300/?gravity=east')\n                },\n                pointSize: {\n                    value: window.devicePixelRatio || 1.0\n                },\n                posTex: {\n                    value: null\n                },\n                velTex: {\n                    value: null\n                }\n            }\n        })\n\n        api.windowStack.onOpacity = (evt) => {\n          var { value } = evt.data.data;\n          // console.log('onOpacity', evt, evt.data.type, value / 100)\n          material.uniforms.opacity.value = value / 100\n        }\n\n        var points = new THREE.Points(geometry, material)\n        points.matrixAutoUpdate = false\n        points.updateMatrix()\n\n        scene.add(points)\n\n        return {\n            material,\n            points\n        }\n    }\n\n    var setupRender = ({\n        renderer,\n        target\n    }) => {\n        var mod = {}\n\n        var scene = new THREE.Scene();\n        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);\n        camera.position.z = 165;\n\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setPixelRatio(window.devicePixelRatio || 1.0)\n        //renderer.domElement.style.marginBottom = '-3px'\n\n        target.appendChild(renderer.domElement);\n\n        api.eventStack.setSize = ({\n            type,\n            rect,\n            aspect\n        }) => {\n            if (type === 'resize' && rect) {\n                // renderer.setSize(rect.width, rect.height);\n                // renderer.setPixelRatio(window.devicePixelRatio || 1.0)\n\n                renderer.setSize(window.innerWidth, window.innerHeight);\n                renderer.setPixelRatio(window.devicePixelRatio || 1.0)\n\n                camera.aspect = aspect;\n                camera.updateProjectionMatrix()\n            }\n        }\n\n        scene.background = new THREE.Color(0x000000);\n\n        var anim = makeAnimatable({\n            scene\n        })\n\n        mod.run = () => {\n            var {\n                velTex,\n                posTex\n            } = api.compute.getTex()\n\n            anim.material.uniforms.posTex.value = posTex\n            anim.material.uniforms.velTex.value = velTex\n\n            renderer.render(scene, camera);\n        }\n\n        return mod\n    }\n\n\n\n    var setupCompute = ({\n        renderer\n    }) => {\n        var mod = {}\n\n        function fillTexture(texture, WIDTH) {\n\n            var pixels = texture.image.data\n            var p = 0\n            for (var j = 0; j < WIDTH; j++) {\n                for (var i = 0; i < WIDTH; i++) {\n                    var x = (WIDTH / 2 - i) * 128 / WIDTH\n                    var y = (WIDTH / 2 - j) * 128 / WIDTH\n\n                    pixels[p + 0] = x\n                    pixels[p + 1] = y\n\n                    pixels[p + 2] = 0 // noise(Math.sin(x), Math.sin(y), 0.0)\n                    pixels[p + 3] = 0\n                    p += 4\n                }\n            }\n        }\n\n        var gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer);\n\n        // Create initial state float textures\n        var pos0 = gpuCompute.createTexture();\n        var vel0 = gpuCompute.createTexture();\n        // and fill in here the texture data...\n        fillTexture(pos0, WIDTH)\n\n        // Add texture variables\n        var velTexSD = require('@/src/webgl/particle/velocitySim.frag');\n        var posTexSD = require('@/src/webgl/particle/positionSim.frag');\n\n        var velVar = gpuCompute.addVariable('velTex', velTexSD.default, pos0);\n        var posVar = gpuCompute.addVariable('posTex', posTexSD.default, vel0);\n\n        // Add variable dependencies\n        gpuCompute.setVariableDependencies(velVar, [velVar, posVar]);\n        gpuCompute.setVariableDependencies(posVar, [velVar, posVar]);\n\n        // Add custom uniforms\n        velVar.material.uniforms = {\n            time: {\n                value: 0.0\n            },\n            mouse: {\n                value: new THREE.Vector2(0, 0)\n            }\n        }\n\n        api.eventStack.mousePos = ({\n            type,\n            pageX,\n            pageY,\n            rect\n        }) => {\n            var velocity = velVar.material.uniforms.mouse.value;\n            if (type === 'mv' && rect) {\n                velocity.x = ((pageX - rect.left) / rect.width) * 2 - 1\n                velocity.y = -((pageY - rect.top) / rect.height) * 2 + 1\n            } else if (type === 'tm' && rect) {\n                velocity.x = ((pageX - rect.left) / rect.width) * 2 - 1\n                velocity.y = -((pageY - rect.top) / rect.height) * 2 + 1\n            }\n        }\n\n        // Check for completeness\n        var error = gpuCompute.init();\n        if (error !== null) {\n            alert(error);\n            console.error(error);\n        }\n        mod.getTex = () => {\n            return {\n                velTex: gpuCompute.getCurrentRenderTarget(velVar).texture,\n                posTex: gpuCompute.getCurrentRenderTarget(posVar).texture\n            }\n        };\n\n        mod.run = () => {\n            velVar.material.uniforms.time.value = window.performance.now() / 1000\n            gpuCompute.compute();\n        }\n        return mod\n    }\n\n    return api;\n}\n\n\n"},{"path":"@/src/webgl/particle/particle.vert","src":"\n\nuniform sampler2D posTex;\nuniform sampler2D velTex;\n\nuniform float pointSize;\n\nvarying vec4 parVel;\nvarying vec2 vUv;\n\nvoid main() {\n    vec4 pos = texture2D(posTex, uv);\n    vec4 vel = texture2D(velTex, uv);\n\n    vec4 mvPosition = modelViewMatrix * vec4( pos.xyz, 1.0 );\n    vec4 outputPos = projectionMatrix * mvPosition;\n\n    vUv = uv;\n    parVel = vel;\n    gl_Position = outputPos;\n    gl_PointSize = pointSize * 1.0;\n}\n\n\n      "},{"path":"@/src/webgl/particle/particle.frag","src":"\n\nvarying vec4 parVel;\nvarying vec2 vUv;\nuniform sampler2D picture;\nuniform float opacity;\n\nvoid main() {\n\n    vec4 rainbow = parVel;\n\n// vec4 outputColor = vec4(\n//         (rainbow.x + 0.6),\n//         (rainbow.y * rainbow.x + 0.6),\n//         (rainbow.y + 0.6),\n//         0.25\n//     );\n// outputColor.xyz = clamp(outputColor.xyz, vec3(0.0), vec3(1.0));\n    vec4 imgColor = texture2D(picture, vUv);\n\n    vec4 outputColor = vec4(0.5, 0.5, 0.5, opacity) * imgColor;\n\n    gl_FragColor = outputColor;\n}\n\n"},{"path":"@/src/webgl/particle/velocitySim.frag","src":"\n\nuniform float time;\nuniform vec2 mouse;\nfloat constrain(float val, float min, float max) {\n    if (val < min) {\n        return min;\n    } else if (val > max) {\n        return max;\n    } else {\n        return val;\n    }\n}\n\nvec3 getDiff (in vec3 lastPos, in vec3 mousePos) {\n  vec3 diff = lastPos.xyz / 33.3 - mousePos;\n  float distance = constrain(length(diff), 5.0, 100.0);\n  float strength = 0.35 / (distance * distance);\n\n  diff = normalize(diff);\n  diff = diff * strength * -2.0;\n\n  return diff;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 lastVel = texture2D( velTex, uv );\n    vec4 lastPos = texture2D( posTex, uv );\n\n    vec3 diff = getDiff( lastPos.xyz, vec3(mouse, 0.1) );\n    lastVel.xyz += diff * 15.0;\n\n    gl_FragColor = lastVel;\n}\n"},{"path":"@/src/webgl/particle/positionSim.frag","src":"\n\n#include <common>\n\n//  Classic Perlin 3D Noise\n//  by Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 *\n      vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n#define M_PI 3.1415926535897932384626433832795\nfloat atan2(in float y, in float x) {\n  bool xgty = (abs(x) > abs(y));\n  return mix(M_PI/2.0 - atan(x,y), atan(y,x), float(xgty));\n}\nvec3 fromBall(float r, float az, float el) {\n  return vec3(\n    r * cos(el) * cos(az),\n    r * cos(el) * sin(az),\n    r * sin(el)\n  );\n}\nvoid toBall(vec3 pos, out float az, out float el) {\n  az = atan2(pos.y, pos.x);\n  el = atan2(pos.z, sqrt(pos.x * pos.x + pos.y * pos.y));\n}\n\n// float az = 0.0;\n// float el = 0.0;\n// vec3 noiser = vec3(lastVel);\n// toBall(noiser, az, el);\n// lastVel.xyz = fromBall(1.0, az, el);\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    vec4 lastVel = texture2D( velTex, uv );\n    vec4 lastPos = texture2D( posTex, uv );\n\n    float az = 0.0;\n    float el = 0.0;\n    vec3 noiser = vec3(lastPos);\n\n    noiser += rand(lastVel.xy) * 0.0000001;\n\n    // noiser += cnoise(lastPos.xy) * 2.5;\n    // noiser += sin(lastPos.x * 0.3) * 2.5;\n    // noiser += sin(lastPos.y * 0.3) * 2.5;\n\n    toBall(noiser, az, el);\n    lastPos.xyz = fromBall(65.0, az, el);\n    lastPos.xyz += lastVel.xyz;\n\n    gl_FragColor = lastPos;\n}\n\n\n"}]