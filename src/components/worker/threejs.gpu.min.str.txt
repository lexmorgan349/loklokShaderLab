/**
 * @author yomboprime https://github.com/yomboprime
 *
 * GPUComputationRenderer, based on SimulationRenderer by zz85
 *
 * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats
 * for each compute element (texel)
 *
 * Each variable has a fragment shader that defines the computation made to obtain the variable in question.
 * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader
 * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.
 *
 * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used
 * as inputs to render the textures of the next frame.
 *
 * The render targets of the variables can be used as input textures for your visualization shaders.
 *
 * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.
 * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...
 *
 * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:
 * #DEFINE resolution vec2( 1024.0, 1024.0 )
 *
 * -------------
 *
 * Basic use:
 *
 * // Initialization...
 *
 * // Create computation renderer
 * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );
 *
 * // Create initial state float textures
 * var pos0 = gpuCompute.createTexture();
 * var vel0 = gpuCompute.createTexture();
 * // and fill in here the texture data...
 *
 * // Add texture variables
 * var velVar = gpuCompute.addVariable( "textureVelocity", fragmentShaderVel, pos0 );
 * var posVar = gpuCompute.addVariable( "texturePosition", fragmentShaderPos, vel0 );
 *
 * // Add variable dependencies
 * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );
 * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );
 *
 * // Add custom uniforms
 * velVar.material.uniforms.time = { value: 0.0 };
 *
 * // Check for completeness
 * var error = gpuCompute.init();
 * if ( error !== null ) {
 *		console.error( error );
  * }
 *
 *
 * // In each frame...
 *
 * // Compute!
 * gpuCompute.compute();
 *
 * // Update texture uniforms in your visualization materials with the gpu renderer output
 * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;
 *
 * // Do your rendering
 * renderer.render( myScene, myCamera );
 *
 * -------------
 *
 * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)
 * Note that the shaders can have multiple input textures.
 *
 * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );
 * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );
 *
 * var inputTexture = gpuCompute.createTexture();
 *
 * // Fill in here inputTexture...
 *
 * myFilter1.uniforms.theTexture.value = inputTexture;
 *
 * var myRenderTarget = gpuCompute.createRenderTarget();
 * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;
 *
 * var outputRenderTarget = gpuCompute.createRenderTarget();
 *
 * // Now use the output texture where you want:
 * myMaterial.uniforms.map.value = outputRenderTarget.texture;
 *
 * // And compute each frame, before rendering to screen:
 * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );
 * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );
 *
 *
 *
 * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.
 * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.
 * @param {WebGLRenderer} renderer The renderer
  */

function GPUComputationRenderer(e,r,t){this.variables=[],this.currentTextureIndex=0;var n=new THREE.Scene,a=new THREE.Camera;a.position.z=1;var i={texture:{value:null}},u=d("uniform sampler2D texture;\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\n\tgl_FragColor = texture2D( texture, uv );\n\n}\n",i),s=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),u);function l(t){t.defines.resolution="vec2( "+e.toFixed(1)+", "+r.toFixed(1)+" )"}function d(e,r){r=r||{};var t=new THREE.ShaderMaterial({uniforms:r,vertexShader:"void main()\t{\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n",fragmentShader:e});return l(t),t}n.add(s),this.addVariable=function(e,r,t){var n={name:e,initialValueTexture:t,material:this.createShaderMaterial(r),dependencies:null,renderTargets:[],wrapS:null,wrapT:null,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};return this.variables.push(n),n},this.setVariableDependencies=function(e,r){e.dependencies=r},this.init=function(){if(!t.extensions.get("OES_texture_float"))return"No OES_texture_float support for float textures.";if(0===t.capabilities.maxVertexTextures)return"No support for vertex shader textures.";for(var n=0;n<this.variables.length;n++){var a=this.variables[n];a.renderTargets[0]=this.createRenderTarget(e,r,a.wrapS,a.wrapT,a.minFilter,a.magFilter),a.renderTargets[1]=this.createRenderTarget(e,r,a.wrapS,a.wrapT,a.minFilter,a.magFilter),this.renderTexture(a.initialValueTexture,a.renderTargets[0]),this.renderTexture(a.initialValueTexture,a.renderTargets[1]);var i=a.material,u=i.uniforms;if(null!==a.dependencies)for(var s=0;s<a.dependencies.length;s++){var l=a.dependencies[s];if(l.name!==a.name){for(var d=!1,o=0;o<this.variables.length;o++)if(l.name===this.variables[o].name){d=!0;break}if(!d)return"Variable dependency not found. Variable="+a.name+", dependency="+l.name}u[l.name]={value:null},i.fragmentShader="\nuniform sampler2D "+l.name+";\n"+i.fragmentShader}}return this.currentTextureIndex=0,null},this.compute=function(){for(var e=this.currentTextureIndex,r=0===this.currentTextureIndex?1:0,t=0,n=this.variables.length;t<n;t++){var a=this.variables[t];if(null!==a.dependencies)for(var i=a.material.uniforms,u=0,s=a.dependencies.length;u<s;u++){var l=a.dependencies[u];i[l.name].value=l.renderTargets[e].texture}this.doRenderTarget(a.material,a.renderTargets[r])}this.currentTextureIndex=r},this.getCurrentRenderTarget=function(e){return e.renderTargets[this.currentTextureIndex]},this.getAlternateRenderTarget=function(e){return e.renderTargets[0===this.currentTextureIndex?1:0]},this.addResolutionDefine=l,this.createShaderMaterial=d,this.createRenderTarget=function(t,n,a,i,u,s){return t=t||e,n=n||r,a=a||THREE.ClampToEdgeWrapping,i=i||THREE.ClampToEdgeWrapping,u=u||THREE.NearestFilter,s=s||THREE.NearestFilter,new THREE.WebGLRenderTarget(t,n,{wrapS:a,wrapT:i,minFilter:u,magFilter:s,format:THREE.RGBAFormat,type:/(iPad|iPhone|iPod)/g.test(navigator.userAgent)?THREE.HalfFloatType:THREE.FloatType,stencilBuffer:!1})},this.createTexture=function(t,n){t=t||e,n=n||r;var a=new Float32Array(t*n*4),i=new THREE.DataTexture(a,e,r,THREE.RGBAFormat,THREE.FloatType);return i.needsUpdate=!0,i},this.renderTexture=function(e,r){i.texture.value=e,this.doRenderTarget(u,r),i.texture.value=null},this.doRenderTarget=function(e,r){s.material=e,t.render(n,a,r),s.material=u}}